#Simulacion Numerica de los casos simplificados

import numpy as np
import matplotlib.pyplot as plt
#from scipy.integrate import odeint

from Integradores import *

g=9.81 #Aceleracion de gravedad cte

#Caso 1: Gravedad y masa cte
#no aplica parte angular

#no depende de t porque nada es variable
def der_gravedad_masa_cte(t, state):

    vel = state[3:6]
    gravedad = np.array([0,0,-g])
    derivs = np.concatenate((vel, gravedad))
    #print(derivs)

    return derivs

def sol_analitica_gravedad_masa_cte(t,state):
    pos = state[0:3]
    vel = state[3:6]

    gravedad = np.array([0,0,-g])
    nueva_pos = pos + vel * t - 0.5 * gravedad * (t **2)
    nueva_vel = vel -gravedad * t

    return nueva_pos, nueva_vel

def simular_dinamica(estado, t_max, dt):
    #print(estado)
    t = 0.0
    it = 0
    #########################################
    #CAMBIO DE METODO DE INTEGRACIÓN
    #Integracion = Euler(self.fun_derivs) ocupa dt=0.005
    Integracion = RungeKutta4(der_gravedad_masa_cte) #ocupa dt=0.1
    #Integracion = RKF45(self.fun_derivs)
    #Integracion = RungeKutta2(self.fun_derivs)
    ##########################################
    
    sim=[estado] #lista de estados de vuelo
    tiempos=[0] #lista de tiempos
    while t < t_max:
        #print(t)
        # Integracion numérica del estado actual
        #el dt_new se usa para que el inetgrador actualize el paso de tiempo
        nuevo_estado = Integracion.step(t, estado, dt)
        #nuevo_estado, dt_new = Integracion.step(t, estado, dt)
        #print(dt_new,dt)
        #dt = dt_new
        #print("dt= ", dt)

        # Avanzar estado
        it += 1
        t += dt
        estado = nuevo_estado

        sim.append(estado)
        tiempos.append(t)

        #Indicar el avance en la simulacion
        if it%500==0:
            print(f"Iteracion {it}, t={t:.1f} s, altitud={estado[2]:.1f} m, vel vert={estado[5]:.1f}")

    return tiempos, sim



#Solucion de ese caso
# Estado inicial
x0, y0, z0 = 0, 0, 0
vx0, vy0, vz0 = 80, 20, 50

#no afecta la masa la dinamica
m = 1.0 #masa cte

estado=np.array([x0, y0, z0, vx0, vy0, vz0])
#print(estado)

#Parametros de la simulacion
dt = 0.1 #0.1 #[s]
t_max = 80 #[s]

#Solucion analitica
Ts = np.linspace(0,t_max, 100)
pos_analitica_x = []
pos_analitica_y = []
pos_analitica_z = []
vel_analitica_x = []
vel_analitica_y = []
vel_analitica_z = []

for t in Ts:
    pos, vel = sol_analitica_gravedad_masa_cte(t, estado)
    pos_analitica_x.append(pos[0])
    pos_analitica_y.append(pos[1])
    pos_analitica_z.append(pos[2])
    vel_analitica_x.append(vel[0])
    vel_analitica_y.append(vel[1])
    vel_analitica_z.append(vel[2])


#Simulacion
tiempos, simulacion = simular_dinamica(estado, t_max, dt)

#Graficar
plt.figure(figsize=(8, 6))
plt.plot(tiempos, [sim[0] for sim in simulacion], label='x(t)')
plt.plot(tiempos, [sim[1] for sim in simulacion], label='y(t)')
plt.plot(tiempos, [sim[2] for sim in simulacion], label='Altura [m] z(t)')
plt.plot(Ts, pos_analitica_x, label='x(t) analitica', linestyle='--')
plt.plot(Ts, pos_analitica_y, label='y(t) analitica', linestyle='--')
plt.plot(Ts, pos_analitica_z, label='z(t) analitica', linestyle='--')
plt.xlabel('Tiempo [s]')
plt.ylabel('Posicion [m]')
plt.legend()
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(tiempos, [sim[3] for sim in simulacion], label='Velocidad vertical [m/s]')
plt.plot(tiempos, [sim[4] for sim in simulacion], label='Velocidad vertical [m/s]')
plt.plot(tiempos, [sim[5] for sim in simulacion], label='Velocidad vertical [m/s]')
plt.xlabel('Tiempo [s]')
plt.ylabel('Altura [m] / Velocidad [m/s]')
plt.legend()
plt.show()
##############################################################################
#Caso 2: Gravedad y masa variable
